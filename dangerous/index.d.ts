declare module "__index" {
	namespace _default {
		export { RealWorld };
		export { RealStory };
		export { RealPromise };
		export { RealNode };
		export { RealGroup };
		export { RealTarget };
		export { RealElement };
		export { createRealDivSelect };
		export { createRealDivSearch };
		export { createRealDivSeries };
		export { RealCanvas };
		export { RealLoader };
		export { RealSelect };
		export { RealComtag };
		export { RealDivList };
		export { RealImgList };
		export { RealDivQueue };
	}
	export default _default;
	class RealWorld {
		private constructor();
		/**## destroy 销毁本对象 */
		destroy(): void;
		/**## then 添加函数入执行队列 */
		then(fn: any): this;
		/**## 生成RealElement实例 */
		getRealElement(): {
			/**@type {Element} */
			self: Element;
			/**
			 *
			 * @template T
			 * @param {T} value
			 */
			protoTransform<T>(value: T): T;
			fix(): /*elided*/ any;
			clearClassName(): boolean;
			/**@param {...String} */
			addClassName(...args: string[]): boolean;
			/**@param {String} className */
			toggleClassName(className: string): boolean;
			/**@param {...String} */
			removeClassName(...args: string[]): boolean;
			getIndexWithin(): number;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {keyof HTMLElementTagNameMap} selfSelector
			 * @param {String | {[selector: String]: {[styleName: String]: String}}} classNameOrRuleObjObj
			 */
			applyCSS(selfSelector: keyof HTMLElementTagNameMap, classNameOrRuleObjObj: string | {
				[selector: string]: {
					[styleName: string]: string;
				};
			}): boolean;
			/**
			 *
			 * @param {Boolean} keepValue
			 * @param {Boolean} fix
			 * @param {Boolean} [deepCopyRelativeRNs]
			 */
			clone(keepValue: boolean, fix: boolean, deepCopyRelativeRNs?: boolean): {
				/**
				 *
				 * @template T
				 * @param {T} value
				 */
				protoTransform<T>(value: T): T;
				fix(): /*elided*/ any;
				clearClassName(): boolean;
				/**@param {...String} */
				addClassName(...args: string[]): boolean;
				/**@param {String} className */
				toggleClassName(className: string): boolean;
				/**@param {...String} */
				removeClassName(...args: string[]): boolean;
				getIndexWithin(): number;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {keyof HTMLElementTagNameMap} selfSelector
				 * @param {String | {[selector: String]: {[styleName: String]: String}}} classNameOrRuleObjObj
				 */
				applyCSS(selfSelector: keyof HTMLElementTagNameMap, classNameOrRuleObjObj: string | {
					[selector: string]: {
						[styleName: string]: string;
					};
				}): boolean;
				clone(keepValue: boolean, fix: boolean, deepCopyRelativeRNs?: boolean): /*elided*/ any;
				readonly isElement: boolean;
				transform: (value: any) => any;
				/**@type { Element | {}} */
				self: Element | {};
				/**@type {AntiTarget} */ proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [{
							protoReact(): void;
							protoGet(): any;
							log(...message: any[]): void;
							done(): Promise<any>;
							/**
							 *
							 * @throws
							 * @param {String} message
							 * @returns {never}
							 */
							error(message: string): never;
							/**
							 *
							 * @returns {Boolean}
							 */
							protoSet(value: any): boolean;
							clearChildRNs(): /*elided*/ any;
							realReact(notify: boolean, noSelf: any): boolean;
							/**
							 *
							 * @returns {Promise[][]}
							 */
							protoDone(): Promise<any>[][];
							/**@type {Promise[][]} */
							notifyArray: Promise<any>[][];
							/**
							 *
							 * @param {Boolean} noSelf
							 * @param {RealNode} [thisArg]
							 * @param {number} [count]
							 * @returns {?Promise<void>}
							 */
							notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
							/**
							 *
							 * @param {Boolean} react
							 * @param {Boolean} notify
							 * @param {Boolean} noSelf
							 * @returns {Boolean}
							 */
							realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
							/**
							 *
							 * @param {RealNode} realNode
							 * @returns {String[][]}
							 */
							_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
							/**
							 *
							 * @param {Boolean} noSelf
							 * @param {RealNode} [thisArg]
							 * @param {number} [count]
							 */
							protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
							/**
							 *
							 * @param {...(RealNode | Symbol)} relativeRNs
							 */
							relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
							/**
							 *
							 * @param {...(RealNode | Symbol)} unrelativeRNs
							 */
							unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
							/**
							 *
							 * @param {String[]} [position]
							 * @returns {[RealNode, ...string[]][]}
							 */
							_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
							/**
							 *
							 * @param {[RealNode, ...string[]][]} realNodeMap
							 */
							_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
							/**@type {Symbol} */
							readonly id: Symbol;
							readonly childRNs: ({
								info: [/*elided*/ any, string[], string[]];
							} & /*elided*/ any)[];
							value: any;
							set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
							get: () => any;
							react: () => boolean;
							display: boolean;
							tryRealNode: boolean;
							/**@type {Symbol[]} */
							relativeRNs: Symbol[];
							/**@type {AntiNode} */
							proto: /*elided*/ any;
							info: any;
							[Symbol.toPrimitive](hint: any): string | number;
						}, string[], string[]];
					} & {
						protoReact(): void;
						protoGet(): any;
						log(...message: any[]): void;
						done(): Promise<any>;
						/**
						 *
						 * @throws
						 * @param {String} message
						 * @returns {never}
						 */
						error(message: string): never;
						/**
						 *
						 * @returns {Boolean}
						 */
						protoSet(value: any): boolean;
						clearChildRNs(): /*elided*/ any;
						realReact(notify: boolean, noSelf: any): boolean;
						/**
						 *
						 * @returns {Promise[][]}
						 */
						protoDone(): Promise<any>[][];
						/**@type {Promise[][]} */
						notifyArray: Promise<any>[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 * @returns {?Promise<void>}
						 */
						notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
						/**
						 *
						 * @param {Boolean} react
						 * @param {Boolean} notify
						 * @param {Boolean} noSelf
						 * @returns {Boolean}
						 */
						realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
						/**
						 *
						 * @param {RealNode} realNode
						 * @returns {String[][]}
						 */
						_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 */
						protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
						/**
						 *
						 * @param {...(RealNode | Symbol)} relativeRNs
						 */
						relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
						/**
						 *
						 * @param {...(RealNode | Symbol)} unrelativeRNs
						 */
						unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
						/**
						 *
						 * @param {String[]} [position]
						 * @returns {[RealNode, ...string[]][]}
						 */
						_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
						/**
						 *
						 * @param {[RealNode, ...string[]][]} realNodeMap
						 */
						_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
						/**@type {Symbol} */
						readonly id: Symbol;
						readonly childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						value: any;
						set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
						get: () => any;
						react: () => boolean;
						display: boolean;
						tryRealNode: boolean;
						/**@type {Symbol[]} */
						relativeRNs: Symbol[];
						/**@type {AntiNode} */
						proto: /*elided*/ any;
						info: any;
						[Symbol.toPrimitive](hint: any): string | number;
					})[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				} & {
					self: Element & {};
					isElement: boolean;
					transform(value: any): any;
				};
				key: any;
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: ({
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				} | Symbol)[]): {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				};
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: ({
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				} | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [{
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [{
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [{
						protoReact(): void;
						protoGet(): any;
						log(...message: any[]): void;
						done(): Promise<any>;
						/**
						 *
						 * @throws
						 * @param {String} message
						 * @returns {never}
						 */
						error(message: string): never;
						/**
						 *
						 * @returns {Boolean}
						 */
						protoSet(value: any): boolean;
						clearChildRNs(): /*elided*/ any;
						realReact(notify: boolean, noSelf: any): boolean;
						/**
						 *
						 * @returns {Promise[][]}
						 */
						protoDone(): Promise<any>[][];
						/**@type {Promise[][]} */
						notifyArray: Promise<any>[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 * @returns {?Promise<void>}
						 */
						notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
						/**
						 *
						 * @param {Boolean} react
						 * @param {Boolean} notify
						 * @param {Boolean} noSelf
						 * @returns {Boolean}
						 */
						realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
						/**
						 *
						 * @param {RealNode} realNode
						 * @returns {String[][]}
						 */
						_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 */
						protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
						/**
						 *
						 * @param {...(RealNode | Symbol)} relativeRNs
						 */
						relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
						/**
						 *
						 * @param {...(RealNode | Symbol)} unrelativeRNs
						 */
						unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
						/**
						 *
						 * @param {String[]} [position]
						 * @returns {[RealNode, ...string[]][]}
						 */
						_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
						/**
						 *
						 * @param {[RealNode, ...string[]][]} realNodeMap
						 */
						_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
						/**@type {Symbol} */
						readonly id: Symbol;
						readonly childRNs: (/*elided*/ any & /*elided*/ any)[];
						value: any;
						set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
						get: () => any;
						react: () => boolean;
						display: boolean;
						tryRealNode: boolean;
						/**@type {Symbol[]} */
						relativeRNs: Symbol[];
						/**@type {AntiNode} */
						proto: {
							tryRealNode: boolean;
							childRNs: ({
								info: [/*elided*/ any, string[], string[]];
							} & /*elided*/ any)[];
							get(): any;
							set(value: any): boolean;
							react(): boolean;
							id: Symbol;
							value: any;
						};
						info: any;
						[Symbol.toPrimitive](hint: any): string | number;
					}, string[], string[]];
				} & {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				})[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			};
			readonly isElement: boolean;
			transform: (value: any) => any;
			/**@type {AntiTarget} */ proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [{
						protoReact(): void;
						protoGet(): any;
						log(...message: any[]): void;
						done(): Promise<any>;
						/**
						 *
						 * @throws
						 * @param {String} message
						 * @returns {never}
						 */
						error(message: string): never;
						/**
						 *
						 * @returns {Boolean}
						 */
						protoSet(value: any): boolean;
						clearChildRNs(): /*elided*/ any;
						realReact(notify: boolean, noSelf: any): boolean;
						/**
						 *
						 * @returns {Promise[][]}
						 */
						protoDone(): Promise<any>[][];
						/**@type {Promise[][]} */
						notifyArray: Promise<any>[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 * @returns {?Promise<void>}
						 */
						notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
						/**
						 *
						 * @param {Boolean} react
						 * @param {Boolean} notify
						 * @param {Boolean} noSelf
						 * @returns {Boolean}
						 */
						realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
						/**
						 *
						 * @param {RealNode} realNode
						 * @returns {String[][]}
						 */
						_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 */
						protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
						/**
						 *
						 * @param {...(RealNode | Symbol)} relativeRNs
						 */
						relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
						/**
						 *
						 * @param {...(RealNode | Symbol)} unrelativeRNs
						 */
						unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
						/**
						 *
						 * @param {String[]} [position]
						 * @returns {[RealNode, ...string[]][]}
						 */
						_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
						/**
						 *
						 * @param {[RealNode, ...string[]][]} realNodeMap
						 */
						_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
						/**@type {Symbol} */
						readonly id: Symbol;
						readonly childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						value: any;
						set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
						get: () => any;
						react: () => boolean;
						display: boolean;
						tryRealNode: boolean;
						/**@type {Symbol[]} */
						relativeRNs: Symbol[];
						/**@type {AntiNode} */
						proto: /*elided*/ any;
						info: any;
						[Symbol.toPrimitive](hint: any): string | number;
					}, string[], string[]];
				} & {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: /*elided*/ any;
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				})[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			} & {
				self: Element & {};
				isElement: boolean;
				transform(value: any): any;
			};
			key: any;
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: ({
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			} | Symbol)[]): {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			};
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: ({
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			} | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [{
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [{
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [{
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: (/*elided*/ any & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, string[], string[]];
			} & {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			})[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		/**## 变更时间间隔 */
		setTimeSep(timeSep: any): boolean;
		_mainFn(): void;
		intervalFn: void;
		info: any;
		ifFn: any;
		soFn: any;
		paused: boolean;
	}
	var RealStory: {
		newPage(): /*elided*/ any;
		/**
		 *
		 * @template T
		 * @param {(page: RealStory)=>T} fn
		 * @returns {Promise<T>}
		 */
		newPrivatePage<T>(fn: (page: /*elided*/ any) => T): Promise<T>;
		then(fn: any): /*elided*/ any;
		getNextPage(): /*elided*/ any;
		getPreviousPage(): /*elided*/ any;
		newPromiseObj(): {
			resolve: (value: any) => void;
			reject: (reason?: any) => void;
			promise: Promise<any>;
		};
		launch(): Promise<void>;
		info: any;
		readonly StoryPromise: {
			(): {
				resolve: (value: any) => void;
				reject: (reason?: any) => void;
				promise: Promise<any>;
			};
			new (): {
				resolve: (value: any) => void;
				reject: (reason?: any) => void;
				promise: Promise<any>;
			};
		};
		readonly index: number;
		/**@type {?RealStory} */
		ofStory: /*elided*/ any | null;
		/**@type {RealStory[]} */
		pages: /*elided*/ any[];
		/**@type {(()=>*)[]} */
		fnList: (() => any)[];
	};
	var RealPromise: {
		/**
		 *
		 * @template T
		 * @param {Promise<T> | T} promise
		 */
		newOne<T>(promise: T | Promise<T>): {
			newOne<T_1>(promise: T_1 | Promise<T_1>): {
				newOne<T_2>(promise: T_2 | Promise<T_2>): {
					newOne<T_3>(promise: T_3 | Promise<T_3>): {
						newOne<T_4>(promise: T_4 | Promise<T_4>): {
							newOne<T_5>(promise: T_5 | Promise<T_5>): {
								newOne<T_6>(promise: T_6 | Promise<T_6>): {
									newOne<T_7>(promise: T_7 | Promise<T_7>): {
										newOne<T_8>(promise: T_8 | Promise<T_8>): {
											newOne<T_9>(promise: T_9 | Promise<T_9>): {
												newOne<T_10>(promise: T_10 | Promise<T_10>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_9>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U>(v: U): U;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U, V>(onfulfilled?: (value: T_9) => U, onrejected?: (reason: any) => V): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_8>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U>(v: U): U;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U, V>(onfulfilled?: (value: T_8) => U, onrejected?: (reason: any) => V): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_7>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U>(v: U): U;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U, V>(onfulfilled?: (value: T_7) => U, onrejected?: (reason: any) => V): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_6>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U>(v: U): U;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U, V>(onfulfilled?: (value: T_6) => U, onrejected?: (reason: any) => V): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_5>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U>(v: U): U;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U, V>(onfulfilled?: (value: T_5) => U, onrejected?: (reason: any) => V): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_4>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U>(v: U): U;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U, V>(onfulfilled?: (value: T_4) => U, onrejected?: (reason: any) => V): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_5>(promise: T_5 | Promise<T_5>): {
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_1, V_1>(onfulfilled?: (value: T_5) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_1>(v: U_1): U_1;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_3>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U>(v: U): U;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U, V>(onfulfilled?: (value: T_3) => U, onrejected?: (reason: any) => V): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_4>(promise: T_4 | Promise<T_4>): {
								newOne<T_5>(promise: T_5 | Promise<T_5>): {
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_1, V_1>(onfulfilled?: (value: T_5) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_1>(v: U_1): U_1;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_1, V_1>(onfulfilled?: (value: T_4) => U_1, onrejected?: (reason: any) => V_1): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_1>(v: U_1): U_1;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<T_2>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U>(v: U): U;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					/**
					 *
					 * @template U
					 * @template V
					 * @param {(value: T)=>U} [onfulfilled]
					 * @param {(reason)=>V} [onrejected]
					 * @returns {RealPromise<U>}
					 */
					then<U, V>(onfulfilled?: (value: T_2) => U, onrejected?: (reason: any) => V): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_3>(promise: T_3 | Promise<T_3>): {
							newOne<T_4>(promise: T_4 | Promise<T_4>): {
								newOne<T_5>(promise: T_5 | Promise<T_5>): {
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_1, V_1>(onfulfilled?: (value: T_5) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_1>(v: U_1): U_1;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_1, V_1>(onfulfilled?: (value: T_4) => U_1, onrejected?: (reason: any) => V_1): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_1>(v: U_1): U_1;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_1, V_1>(onfulfilled?: (value: T_3) => U_1, onrejected?: (reason: any) => V_1): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_1>(v: U_1): U_1;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @param {(reason)=>*} [onrejected]
				 */
				catch(onrejected?: (reason: any) => any): /*elided*/ any;
				self: Promise<T_1>;
				/**
				 *
				 * @param {()=>void} [onfinally]
				 */
				finally(onfinally?: () => void): /*elided*/ any;
				/**
				 *
				 * @template U
				 * @param {U} v
				 */
				_push<U>(v: U): U;
				/**
				 * @throws
				 * @returns {never}
				 */
				_throw(e: any): never;
				/**
				 *
				 * @template U
				 * @template V
				 * @param {(value: T)=>U} [onfulfilled]
				 * @param {(reason)=>V} [onrejected]
				 * @returns {RealPromise<U>}
				 */
				then<U, V>(onfulfilled?: (value: T_1) => U, onrejected?: (reason: any) => V): {
					/**
					 *
					 * @template T
					 * @param {Promise<T> | T} promise
					 */
					newOne<T_2>(promise: T_2 | Promise<T_2>): {
						newOne<T_3>(promise: T_3 | Promise<T_3>): {
							newOne<T_4>(promise: T_4 | Promise<T_4>): {
								newOne<T_5>(promise: T_5 | Promise<T_5>): {
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_1, V_1>(onfulfilled?: (value: T_5) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_1>(v: U_1): U_1;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_1, V_1>(onfulfilled?: (value: T_4) => U_1, onrejected?: (reason: any) => V_1): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_1>(v: U_1): U_1;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_1, V_1>(onfulfilled?: (value: T_3) => U_1, onrejected?: (reason: any) => V_1): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_2>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_1>(v: U_1): U_1;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_1, V_1>(onfulfilled?: (value: T_2) => U_1, onrejected?: (reason: any) => V_1): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<U>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_1>(v: U_1): U_1;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_2>(promise: T_2 | Promise<T_2>): {
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_2, V_2>(onfulfilled?: (value: T_2) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_1>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_2>(v: U_2): U_2;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @template U
				 * @param {(v)=>U} handler
				 * @param {(error: Error)=>void} [onerror]
				 */
				tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
				readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
				readonly length: number;
				list: any[];
			};
			/**
			 *
			 * @param {(reason)=>*} [onrejected]
			 */
			catch(onrejected?: (reason: any) => any): /*elided*/ any;
			self: Promise<T>;
			/**
			 *
			 * @param {()=>void} [onfinally]
			 */
			finally(onfinally?: () => void): /*elided*/ any;
			/**
			 *
			 * @template U
			 * @param {U} v
			 */
			_push<U>(v: U): U;
			/**
			 * @throws
			 * @returns {never}
			 */
			_throw(e: any): never;
			/**
			 *
			 * @template U
			 * @template V
			 * @param {(value: T)=>U} [onfulfilled]
			 * @param {(reason)=>V} [onrejected]
			 * @returns {RealPromise<U>}
			 */
			then<U, V>(onfulfilled?: (value: T) => U, onrejected?: (reason: any) => V): {
				/**
				 *
				 * @template T
				 * @param {Promise<T> | T} promise
				 */
				newOne<T_1>(promise: T_1 | Promise<T_1>): {
					newOne<T_2>(promise: T_2 | Promise<T_2>): {
						newOne<T_3>(promise: T_3 | Promise<T_3>): {
							newOne<T_4>(promise: T_4 | Promise<T_4>): {
								newOne<T_5>(promise: T_5 | Promise<T_5>): {
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_1, V_1>(onfulfilled?: (value: T_5) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_1>(v: U_1): U_1;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_1, V_1>(onfulfilled?: (value: T_4) => U_1, onrejected?: (reason: any) => V_1): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_1>(v: U_1): U_1;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_1, V_1>(onfulfilled?: (value: T_3) => U_1, onrejected?: (reason: any) => V_1): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_2>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_1>(v: U_1): U_1;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_1, V_1>(onfulfilled?: (value: T_2) => U_1, onrejected?: (reason: any) => V_1): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<T_1>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_1>(v: U_1): U_1;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					/**
					 *
					 * @template U
					 * @template V
					 * @param {(value: T)=>U} [onfulfilled]
					 * @param {(reason)=>V} [onrejected]
					 * @returns {RealPromise<U>}
					 */
					then<U_1, V_1>(onfulfilled?: (value: T_1) => U_1, onrejected?: (reason: any) => V_1): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_2>(promise: T_2 | Promise<T_2>): {
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_2, V_2>(onfulfilled?: (value: T_2) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_1>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_2>(v: U_2): U_2;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @param {(reason)=>*} [onrejected]
				 */
				catch(onrejected?: (reason: any) => any): /*elided*/ any;
				self: Promise<U>;
				/**
				 *
				 * @param {()=>void} [onfinally]
				 */
				finally(onfinally?: () => void): /*elided*/ any;
				/**
				 *
				 * @template U
				 * @param {U} v
				 */
				_push<U_1>(v: U_1): U_1;
				/**
				 * @throws
				 * @returns {never}
				 */
				_throw(e: any): never;
				then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
					/**
					 *
					 * @template T
					 * @param {Promise<T> | T} promise
					 */
					newOne<T_1>(promise: T_1 | Promise<T_1>): {
						newOne<T_2>(promise: T_2 | Promise<T_2>): {
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_2, V_2>(onfulfilled?: (value: T_2) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_1>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_2>(v: U_2): U_2;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_2, V_2>(onfulfilled?: (value: T_1) => U_2, onrejected?: (reason: any) => V_2): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<U_1>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_2>(v: U_2): U_2;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_1>(promise: T_1 | Promise<T_1>): {
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_3, V_3>(onfulfilled?: (value: T_1) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_2>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_3>(v: U_3): U_3;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_1>(promise: T_1 | Promise<T_1>): {
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_4, V_4>(onfulfilled?: (value: T_1) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_4>(v: U_4): U_4;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_1>(promise: T_1 | Promise<T_1>): {
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_5, V_5>(onfulfilled?: (value: T_1) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_5>(v: U_5): U_5;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @template U
				 * @param {(v)=>U} handler
				 * @param {(error: Error)=>void} [onerror]
				 */
				tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
				readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
				readonly length: number;
				list: any[];
			};
			/**
			 *
			 * @template U
			 * @param {(v)=>U} handler
			 * @param {(error: Error)=>void} [onerror]
			 */
			tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
			readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
			readonly length: number;
			list: any[];
		};
		/**
		 *
		 * @param {(reason)=>*} [onrejected]
		 */
		catch(onrejected?: (reason: any) => any): /*elided*/ any;
		self: Promise<any>;
		/**
		 *
		 * @param {()=>void} [onfinally]
		 */
		finally(onfinally?: () => void): /*elided*/ any;
		/**
		 *
		 * @template U
		 * @param {U} v
		 */
		_push<U>(v: U): U;
		/**
		 * @throws
		 * @returns {never}
		 */
		_throw(e: any): never;
		/**
		 *
		 * @template U
		 * @template V
		 * @param {(value: T)=>U} [onfulfilled]
		 * @param {(reason)=>V} [onrejected]
		 * @returns {RealPromise<U>}
		 */
		then<U, V>(onfulfilled?: (value: any) => U, onrejected?: (reason: any) => V): {
			/**
			 *
			 * @template T
			 * @param {Promise<T> | T} promise
			 */
			newOne<T>(promise: T | Promise<T>): {
				newOne<T_1>(promise: T_1 | Promise<T_1>): {
					newOne<T_2>(promise: T_2 | Promise<T_2>): {
						newOne<T_3>(promise: T_3 | Promise<T_3>): {
							newOne<T_4>(promise: T_4 | Promise<T_4>): {
								newOne<T_5>(promise: T_5 | Promise<T_5>): {
									newOne<T_6>(promise: T_6 | Promise<T_6>): {
										newOne<T_7>(promise: T_7 | Promise<T_7>): {
											newOne<T_8>(promise: T_8 | Promise<T_8>): {
												newOne<T_9>(promise: T_9 | Promise<T_9>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_1>(v: U_1): U_1;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_1, V_1>(onfulfilled?: (value: T_8) => U_1, onrejected?: (reason: any) => V_1): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_1>(v: U_1): U_1;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_1, V_1>(onfulfilled?: (value: T_7) => U_1, onrejected?: (reason: any) => V_1): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_1>(v: U_1): U_1;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_1, V_1>(onfulfilled?: (value: T_6) => U_1, onrejected?: (reason: any) => V_1): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_1>(v: U_1): U_1;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_1, V_1>(onfulfilled?: (value: T_5) => U_1, onrejected?: (reason: any) => V_1): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_1>(v: U_1): U_1;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_1, V_1>(onfulfilled?: (value: T_4) => U_1, onrejected?: (reason: any) => V_1): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_1>(v: U_1): U_1;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_1, V_1>(onfulfilled?: (value: T_3) => U_1, onrejected?: (reason: any) => V_1): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_2>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_1>(v: U_1): U_1;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_1, V_1>(onfulfilled?: (value: T_2) => U_1, onrejected?: (reason: any) => V_1): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<T_1>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_1>(v: U_1): U_1;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					/**
					 *
					 * @template U
					 * @template V
					 * @param {(value: T)=>U} [onfulfilled]
					 * @param {(reason)=>V} [onrejected]
					 * @returns {RealPromise<U>}
					 */
					then<U_1, V_1>(onfulfilled?: (value: T_1) => U_1, onrejected?: (reason: any) => V_1): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_2>(promise: T_2 | Promise<T_2>): {
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_2, V_2>(onfulfilled?: (value: T_2) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_1>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_2>(v: U_2): U_2;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @param {(reason)=>*} [onrejected]
				 */
				catch(onrejected?: (reason: any) => any): /*elided*/ any;
				self: Promise<T>;
				/**
				 *
				 * @param {()=>void} [onfinally]
				 */
				finally(onfinally?: () => void): /*elided*/ any;
				/**
				 *
				 * @template U
				 * @param {U} v
				 */
				_push<U_1>(v: U_1): U_1;
				/**
				 * @throws
				 * @returns {never}
				 */
				_throw(e: any): never;
				/**
				 *
				 * @template U
				 * @template V
				 * @param {(value: T)=>U} [onfulfilled]
				 * @param {(reason)=>V} [onrejected]
				 * @returns {RealPromise<U>}
				 */
				then<U_1, V_1>(onfulfilled?: (value: T) => U_1, onrejected?: (reason: any) => V_1): {
					/**
					 *
					 * @template T
					 * @param {Promise<T> | T} promise
					 */
					newOne<T_1>(promise: T_1 | Promise<T_1>): {
						newOne<T_2>(promise: T_2 | Promise<T_2>): {
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_2, V_2>(onfulfilled?: (value: T_2) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_1>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_2>(v: U_2): U_2;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_2, V_2>(onfulfilled?: (value: T_1) => U_2, onrejected?: (reason: any) => V_2): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<U_1>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_2>(v: U_2): U_2;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_1>(promise: T_1 | Promise<T_1>): {
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_3, V_3>(onfulfilled?: (value: T_1) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_2>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_3>(v: U_3): U_3;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_1>(promise: T_1 | Promise<T_1>): {
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_4, V_4>(onfulfilled?: (value: T_1) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_4>(v: U_4): U_4;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_1>(promise: T_1 | Promise<T_1>): {
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_5, V_5>(onfulfilled?: (value: T_1) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_5>(v: U_5): U_5;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @template U
				 * @param {(v)=>U} handler
				 * @param {(error: Error)=>void} [onerror]
				 */
				tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
				readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
				readonly length: number;
				list: any[];
			};
			/**
			 *
			 * @param {(reason)=>*} [onrejected]
			 */
			catch(onrejected?: (reason: any) => any): /*elided*/ any;
			self: Promise<U>;
			/**
			 *
			 * @param {()=>void} [onfinally]
			 */
			finally(onfinally?: () => void): /*elided*/ any;
			/**
			 *
			 * @template U
			 * @param {U} v
			 */
			_push<U_1>(v: U_1): U_1;
			/**
			 * @throws
			 * @returns {never}
			 */
			_throw(e: any): never;
			then<U_1, V_1>(onfulfilled?: (value: U) => U_1, onrejected?: (reason: any) => V_1): {
				/**
				 *
				 * @template T
				 * @param {Promise<T> | T} promise
				 */
				newOne<T>(promise: T | Promise<T>): {
					newOne<T_1>(promise: T_1 | Promise<T_1>): {
						newOne<T_2>(promise: T_2 | Promise<T_2>): {
							newOne<T_3>(promise: T_3 | Promise<T_3>): {
								newOne<T_4>(promise: T_4 | Promise<T_4>): {
									newOne<T_5>(promise: T_5 | Promise<T_5>): {
										newOne<T_6>(promise: T_6 | Promise<T_6>): {
											newOne<T_7>(promise: T_7 | Promise<T_7>): {
												newOne<T_8>(promise: T_8 | Promise<T_8>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_2>(v: U_2): U_2;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_2, V_2>(onfulfilled?: (value: T_7) => U_2, onrejected?: (reason: any) => V_2): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_2>(v: U_2): U_2;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_2, V_2>(onfulfilled?: (value: T_6) => U_2, onrejected?: (reason: any) => V_2): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_2>(v: U_2): U_2;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_2, V_2>(onfulfilled?: (value: T_5) => U_2, onrejected?: (reason: any) => V_2): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_2>(v: U_2): U_2;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_2, V_2>(onfulfilled?: (value: T_4) => U_2, onrejected?: (reason: any) => V_2): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_2>(v: U_2): U_2;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_2, V_2>(onfulfilled?: (value: T_3) => U_2, onrejected?: (reason: any) => V_2): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_2>(v: U_2): U_2;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_2, V_2>(onfulfilled?: (value: T_2) => U_2, onrejected?: (reason: any) => V_2): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T_1>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_2>(v: U_2): U_2;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_2, V_2>(onfulfilled?: (value: T_1) => U_2, onrejected?: (reason: any) => V_2): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_2>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<T>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_2>(v: U_2): U_2;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					/**
					 *
					 * @template U
					 * @template V
					 * @param {(value: T)=>U} [onfulfilled]
					 * @param {(reason)=>V} [onrejected]
					 * @returns {RealPromise<U>}
					 */
					then<U_2, V_2>(onfulfilled?: (value: T) => U_2, onrejected?: (reason: any) => V_2): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T_1>(promise: T_1 | Promise<T_1>): {
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_3, V_3>(onfulfilled?: (value: T_1) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_2>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_3>(v: U_3): U_3;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_1>(promise: T_1 | Promise<T_1>): {
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_4, V_4>(onfulfilled?: (value: T_1) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_4>(v: U_4): U_4;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_1>(promise: T_1 | Promise<T_1>): {
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_5, V_5>(onfulfilled?: (value: T_1) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_5>(v: U_5): U_5;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @param {(reason)=>*} [onrejected]
				 */
				catch(onrejected?: (reason: any) => any): /*elided*/ any;
				self: Promise<U_1>;
				/**
				 *
				 * @param {()=>void} [onfinally]
				 */
				finally(onfinally?: () => void): /*elided*/ any;
				/**
				 *
				 * @template U
				 * @param {U} v
				 */
				_push<U_2>(v: U_2): U_2;
				/**
				 * @throws
				 * @returns {never}
				 */
				_throw(e: any): never;
				then<U_2, V_2>(onfulfilled?: (value: U_1) => U_2, onrejected?: (reason: any) => V_2): {
					/**
					 *
					 * @template T
					 * @param {Promise<T> | T} promise
					 */
					newOne<T>(promise: T | Promise<T>): {
						newOne<T_1>(promise: T_1 | Promise<T_1>): {
							newOne<T_2>(promise: T_2 | Promise<T_2>): {
								newOne<T_3>(promise: T_3 | Promise<T_3>): {
									newOne<T_4>(promise: T_4 | Promise<T_4>): {
										newOne<T_5>(promise: T_5 | Promise<T_5>): {
											newOne<T_6>(promise: T_6 | Promise<T_6>): {
												newOne<T_7>(promise: T_7 | Promise<T_7>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_3>(v: U_3): U_3;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_3, V_3>(onfulfilled?: (value: T_6) => U_3, onrejected?: (reason: any) => V_3): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_3>(v: U_3): U_3;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_3, V_3>(onfulfilled?: (value: T_5) => U_3, onrejected?: (reason: any) => V_3): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_3>(v: U_3): U_3;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_3, V_3>(onfulfilled?: (value: T_4) => U_3, onrejected?: (reason: any) => V_3): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_3>(v: U_3): U_3;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_3, V_3>(onfulfilled?: (value: T_3) => U_3, onrejected?: (reason: any) => V_3): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_2>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_3>(v: U_3): U_3;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_3, V_3>(onfulfilled?: (value: T_2) => U_3, onrejected?: (reason: any) => V_3): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_3>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T_1>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_3>(v: U_3): U_3;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_3, V_3>(onfulfilled?: (value: T_1) => U_3, onrejected?: (reason: any) => V_3): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_3>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<T>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_3>(v: U_3): U_3;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						/**
						 *
						 * @template U
						 * @template V
						 * @param {(value: T)=>U} [onfulfilled]
						 * @param {(reason)=>V} [onrejected]
						 * @returns {RealPromise<U>}
						 */
						then<U_3, V_3>(onfulfilled?: (value: T) => U_3, onrejected?: (reason: any) => V_3): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T_1>(promise: T_1 | Promise<T_1>): {
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_4, V_4>(onfulfilled?: (value: T_1) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_3>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_4>(v: U_4): U_4;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_1>(promise: T_1 | Promise<T_1>): {
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_5, V_5>(onfulfilled?: (value: T_1) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_5>(v: U_5): U_5;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @param {(reason)=>*} [onrejected]
					 */
					catch(onrejected?: (reason: any) => any): /*elided*/ any;
					self: Promise<U_2>;
					/**
					 *
					 * @param {()=>void} [onfinally]
					 */
					finally(onfinally?: () => void): /*elided*/ any;
					/**
					 *
					 * @template U
					 * @param {U} v
					 */
					_push<U_3>(v: U_3): U_3;
					/**
					 * @throws
					 * @returns {never}
					 */
					_throw(e: any): never;
					then<U_3, V_3>(onfulfilled?: (value: U_2) => U_3, onrejected?: (reason: any) => V_3): {
						/**
						 *
						 * @template T
						 * @param {Promise<T> | T} promise
						 */
						newOne<T>(promise: T | Promise<T>): {
							newOne<T_1>(promise: T_1 | Promise<T_1>): {
								newOne<T_2>(promise: T_2 | Promise<T_2>): {
									newOne<T_3>(promise: T_3 | Promise<T_3>): {
										newOne<T_4>(promise: T_4 | Promise<T_4>): {
											newOne<T_5>(promise: T_5 | Promise<T_5>): {
												newOne<T_6>(promise: T_6 | Promise<T_6>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_4>(v: U_4): U_4;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_4, V_4>(onfulfilled?: (value: T_5) => U_4, onrejected?: (reason: any) => V_4): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_4>(v: U_4): U_4;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_4, V_4>(onfulfilled?: (value: T_4) => U_4, onrejected?: (reason: any) => V_4): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_3>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_4>(v: U_4): U_4;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_4, V_4>(onfulfilled?: (value: T_3) => U_4, onrejected?: (reason: any) => V_4): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_4>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_2>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_4>(v: U_4): U_4;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_4, V_4>(onfulfilled?: (value: T_2) => U_4, onrejected?: (reason: any) => V_4): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_4>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T_1>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_4>(v: U_4): U_4;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_4, V_4>(onfulfilled?: (value: T_1) => U_4, onrejected?: (reason: any) => V_4): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_4>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<T>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_4>(v: U_4): U_4;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							/**
							 *
							 * @template U
							 * @template V
							 * @param {(value: T)=>U} [onfulfilled]
							 * @param {(reason)=>V} [onrejected]
							 * @returns {RealPromise<U>}
							 */
							then<U_4, V_4>(onfulfilled?: (value: T) => U_4, onrejected?: (reason: any) => V_4): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T_1>(promise: T_1 | Promise<T_1>): {
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_5, V_5>(onfulfilled?: (value: T_1) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_4>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_5>(v: U_5): U_5;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @param {(reason)=>*} [onrejected]
						 */
						catch(onrejected?: (reason: any) => any): /*elided*/ any;
						self: Promise<U_3>;
						/**
						 *
						 * @param {()=>void} [onfinally]
						 */
						finally(onfinally?: () => void): /*elided*/ any;
						/**
						 *
						 * @template U
						 * @param {U} v
						 */
						_push<U_4>(v: U_4): U_4;
						/**
						 * @throws
						 * @returns {never}
						 */
						_throw(e: any): never;
						then<U_4, V_4>(onfulfilled?: (value: U_3) => U_4, onrejected?: (reason: any) => V_4): {
							/**
							 *
							 * @template T
							 * @param {Promise<T> | T} promise
							 */
							newOne<T>(promise: T | Promise<T>): {
								newOne<T_1>(promise: T_1 | Promise<T_1>): {
									newOne<T_2>(promise: T_2 | Promise<T_2>): {
										newOne<T_3>(promise: T_3 | Promise<T_3>): {
											newOne<T_4>(promise: T_4 | Promise<T_4>): {
												newOne<T_5>(promise: T_5 | Promise<T_5>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_4>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_5>(v: U_5): U_5;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_5, V_5>(onfulfilled?: (value: T_4) => U_5, onrejected?: (reason: any) => V_5): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_3>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_5>(v: U_5): U_5;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_5, V_5>(onfulfilled?: (value: T_3) => U_5, onrejected?: (reason: any) => V_5): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_5>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_2>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_5>(v: U_5): U_5;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_5, V_5>(onfulfilled?: (value: T_2) => U_5, onrejected?: (reason: any) => V_5): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_5>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T_1>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_5>(v: U_5): U_5;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_5, V_5>(onfulfilled?: (value: T_1) => U_5, onrejected?: (reason: any) => V_5): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_5>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<T>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_5>(v: U_5): U_5;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								/**
								 *
								 * @template U
								 * @template V
								 * @param {(value: T)=>U} [onfulfilled]
								 * @param {(reason)=>V} [onrejected]
								 * @returns {RealPromise<U>}
								 */
								then<U_5, V_5>(onfulfilled?: (value: T) => U_5, onrejected?: (reason: any) => V_5): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_5>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @param {(reason)=>*} [onrejected]
							 */
							catch(onrejected?: (reason: any) => any): /*elided*/ any;
							self: Promise<U_4>;
							/**
							 *
							 * @param {()=>void} [onfinally]
							 */
							finally(onfinally?: () => void): /*elided*/ any;
							/**
							 *
							 * @template U
							 * @param {U} v
							 */
							_push<U_5>(v: U_5): U_5;
							/**
							 * @throws
							 * @returns {never}
							 */
							_throw(e: any): never;
							then<U_5, V_5>(onfulfilled?: (value: U_4) => U_5, onrejected?: (reason: any) => V_5): {
								/**
								 *
								 * @template T
								 * @param {Promise<T> | T} promise
								 */
								newOne<T>(promise: T | Promise<T>): {
									newOne<T_1>(promise: T_1 | Promise<T_1>): {
										newOne<T_2>(promise: T_2 | Promise<T_2>): {
											newOne<T_3>(promise: T_3 | Promise<T_3>): {
												newOne<T_4>(promise: T_4 | Promise<T_4>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_3>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_6>(v: U_6): U_6;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_6, V_6>(onfulfilled?: (value: T_3) => U_6, onrejected?: (reason: any) => V_6): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_2>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_6>(v: U_6): U_6;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_6, V_6>(onfulfilled?: (value: T_2) => U_6, onrejected?: (reason: any) => V_6): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_6>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T_1>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_6>(v: U_6): U_6;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_6, V_6>(onfulfilled?: (value: T_1) => U_6, onrejected?: (reason: any) => V_6): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_6>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<T>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_6>(v: U_6): U_6;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									/**
									 *
									 * @template U
									 * @template V
									 * @param {(value: T)=>U} [onfulfilled]
									 * @param {(reason)=>V} [onrejected]
									 * @returns {RealPromise<U>}
									 */
									then<U_6, V_6>(onfulfilled?: (value: T) => U_6, onrejected?: (reason: any) => V_6): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_6>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @param {(reason)=>*} [onrejected]
								 */
								catch(onrejected?: (reason: any) => any): /*elided*/ any;
								self: Promise<U_5>;
								/**
								 *
								 * @param {()=>void} [onfinally]
								 */
								finally(onfinally?: () => void): /*elided*/ any;
								/**
								 *
								 * @template U
								 * @param {U} v
								 */
								_push<U_6>(v: U_6): U_6;
								/**
								 * @throws
								 * @returns {never}
								 */
								_throw(e: any): never;
								then<U_6, V_6>(onfulfilled?: (value: U_5) => U_6, onrejected?: (reason: any) => V_6): {
									/**
									 *
									 * @template T
									 * @param {Promise<T> | T} promise
									 */
									newOne<T>(promise: T | Promise<T>): {
										newOne<T_1>(promise: T_1 | Promise<T_1>): {
											newOne<T_2>(promise: T_2 | Promise<T_2>): {
												newOne<T_3>(promise: T_3 | Promise<T_3>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_2>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_7>(v: U_7): U_7;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_7, V_7>(onfulfilled?: (value: T_2) => U_7, onrejected?: (reason: any) => V_7): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T_1>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_7>(v: U_7): U_7;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_7, V_7>(onfulfilled?: (value: T_1) => U_7, onrejected?: (reason: any) => V_7): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_7>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<T>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_7>(v: U_7): U_7;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										/**
										 *
										 * @template U
										 * @template V
										 * @param {(value: T)=>U} [onfulfilled]
										 * @param {(reason)=>V} [onrejected]
										 * @returns {RealPromise<U>}
										 */
										then<U_7, V_7>(onfulfilled?: (value: T) => U_7, onrejected?: (reason: any) => V_7): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_7>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @param {(reason)=>*} [onrejected]
									 */
									catch(onrejected?: (reason: any) => any): /*elided*/ any;
									self: Promise<U_6>;
									/**
									 *
									 * @param {()=>void} [onfinally]
									 */
									finally(onfinally?: () => void): /*elided*/ any;
									/**
									 *
									 * @template U
									 * @param {U} v
									 */
									_push<U_7>(v: U_7): U_7;
									/**
									 * @throws
									 * @returns {never}
									 */
									_throw(e: any): never;
									then<U_7, V_7>(onfulfilled?: (value: U_6) => U_7, onrejected?: (reason: any) => V_7): {
										/**
										 *
										 * @template T
										 * @param {Promise<T> | T} promise
										 */
										newOne<T>(promise: T | Promise<T>): {
											newOne<T_1>(promise: T_1 | Promise<T_1>): {
												newOne<T_2>(promise: T_2 | Promise<T_2>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T_1>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_8>(v: U_8): U_8;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_8, V_8>(onfulfilled?: (value: T_1) => U_8, onrejected?: (reason: any) => V_8): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<T>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_8>(v: U_8): U_8;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											/**
											 *
											 * @template U
											 * @template V
											 * @param {(value: T)=>U} [onfulfilled]
											 * @param {(reason)=>V} [onrejected]
											 * @returns {RealPromise<U>}
											 */
											then<U_8, V_8>(onfulfilled?: (value: T) => U_8, onrejected?: (reason: any) => V_8): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_8>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @param {(reason)=>*} [onrejected]
										 */
										catch(onrejected?: (reason: any) => any): /*elided*/ any;
										self: Promise<U_7>;
										/**
										 *
										 * @param {()=>void} [onfinally]
										 */
										finally(onfinally?: () => void): /*elided*/ any;
										/**
										 *
										 * @template U
										 * @param {U} v
										 */
										_push<U_8>(v: U_8): U_8;
										/**
										 * @throws
										 * @returns {never}
										 */
										_throw(e: any): never;
										then<U_8, V_8>(onfulfilled?: (value: U_7) => U_8, onrejected?: (reason: any) => V_8): {
											/**
											 *
											 * @template T
											 * @param {Promise<T> | T} promise
											 */
											newOne<T>(promise: T | Promise<T>): {
												newOne<T_1>(promise: T_1 | Promise<T_1>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<T>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_9>(v: U_9): U_9;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												/**
												 *
												 * @template U
												 * @template V
												 * @param {(value: T)=>U} [onfulfilled]
												 * @param {(reason)=>V} [onrejected]
												 * @returns {RealPromise<U>}
												 */
												then<U_9, V_9>(onfulfilled?: (value: T) => U_9, onrejected?: (reason: any) => V_9): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @param {(reason)=>*} [onrejected]
											 */
											catch(onrejected?: (reason: any) => any): /*elided*/ any;
											self: Promise<U_8>;
											/**
											 *
											 * @param {()=>void} [onfinally]
											 */
											finally(onfinally?: () => void): /*elided*/ any;
											/**
											 *
											 * @template U
											 * @param {U} v
											 */
											_push<U_9>(v: U_9): U_9;
											/**
											 * @throws
											 * @returns {never}
											 */
											_throw(e: any): never;
											then<U_9, V_9>(onfulfilled?: (value: U_8) => U_9, onrejected?: (reason: any) => V_9): {
												/**
												 *
												 * @template T
												 * @param {Promise<T> | T} promise
												 */
												newOne<T>(promise: T | Promise<T>): /*elided*/ any;
												/**
												 *
												 * @param {(reason)=>*} [onrejected]
												 */
												catch(onrejected?: (reason: any) => any): /*elided*/ any;
												self: Promise<U_9>;
												/**
												 *
												 * @param {()=>void} [onfinally]
												 */
												finally(onfinally?: () => void): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {U} v
												 */
												_push<U_10>(v: U_10): U_10;
												/**
												 * @throws
												 * @returns {never}
												 */
												_throw(e: any): never;
												then<U_10, V_10>(onfulfilled?: (value: U_9) => U_10, onrejected?: (reason: any) => V_10): /*elided*/ any;
												/**
												 *
												 * @template U
												 * @param {(v)=>U} handler
												 * @param {(error: Error)=>void} [onerror]
												 */
												tryHandler<U_10>(handler: (v: any) => U_10, onerror?: (error: Error) => void): Promise<U_10>;
												readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
												readonly length: number;
												list: any[];
											};
											/**
											 *
											 * @template U
											 * @param {(v)=>U} handler
											 * @param {(error: Error)=>void} [onerror]
											 */
											tryHandler<U_9>(handler: (v: any) => U_9, onerror?: (error: Error) => void): Promise<U_9>;
											readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
											readonly length: number;
											list: any[];
										};
										/**
										 *
										 * @template U
										 * @param {(v)=>U} handler
										 * @param {(error: Error)=>void} [onerror]
										 */
										tryHandler<U_8>(handler: (v: any) => U_8, onerror?: (error: Error) => void): Promise<U_8>;
										readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
										readonly length: number;
										list: any[];
									};
									/**
									 *
									 * @template U
									 * @param {(v)=>U} handler
									 * @param {(error: Error)=>void} [onerror]
									 */
									tryHandler<U_7>(handler: (v: any) => U_7, onerror?: (error: Error) => void): Promise<U_7>;
									readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
									readonly length: number;
									list: any[];
								};
								/**
								 *
								 * @template U
								 * @param {(v)=>U} handler
								 * @param {(error: Error)=>void} [onerror]
								 */
								tryHandler<U_6>(handler: (v: any) => U_6, onerror?: (error: Error) => void): Promise<U_6>;
								readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
								readonly length: number;
								list: any[];
							};
							/**
							 *
							 * @template U
							 * @param {(v)=>U} handler
							 * @param {(error: Error)=>void} [onerror]
							 */
							tryHandler<U_5>(handler: (v: any) => U_5, onerror?: (error: Error) => void): Promise<U_5>;
							readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
							readonly length: number;
							list: any[];
						};
						/**
						 *
						 * @template U
						 * @param {(v)=>U} handler
						 * @param {(error: Error)=>void} [onerror]
						 */
						tryHandler<U_4>(handler: (v: any) => U_4, onerror?: (error: Error) => void): Promise<U_4>;
						readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
						readonly length: number;
						list: any[];
					};
					/**
					 *
					 * @template U
					 * @param {(v)=>U} handler
					 * @param {(error: Error)=>void} [onerror]
					 */
					tryHandler<U_3>(handler: (v: any) => U_3, onerror?: (error: Error) => void): Promise<U_3>;
					readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
					readonly length: number;
					list: any[];
				};
				/**
				 *
				 * @template U
				 * @param {(v)=>U} handler
				 * @param {(error: Error)=>void} [onerror]
				 */
				tryHandler<U_2>(handler: (v: any) => U_2, onerror?: (error: Error) => void): Promise<U_2>;
				readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
				readonly length: number;
				list: any[];
			};
			/**
			 *
			 * @template U
			 * @param {(v)=>U} handler
			 * @param {(error: Error)=>void} [onerror]
			 */
			tryHandler<U_1>(handler: (v: any) => U_1, onerror?: (error: Error) => void): Promise<U_1>;
			readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
			readonly length: number;
			list: any[];
		};
		/**
		 *
		 * @template U
		 * @param {(v)=>U} handler
		 * @param {(error: Error)=>void} [onerror]
		 */
		tryHandler<U>(handler: (v: any) => U, onerror?: (error: Error) => void): Promise<U>;
		readonly require: (this: /*elided*/ any, path: any) => Promise<any>;
		readonly length: number;
		list: any[];
	};
	var RealNode: {
		new (config?: {
			get?: () => any;
			set?: (value: any) => boolean;
			react?: () => void;
			id?: any;
			info?: any;
			value?: any;
			initValue?: any;
			display?: any;
		}, tryRealNode?: boolean, ...relativeRNs?: (Symbol | {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		})[]): {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		/**
		 *
		 * @throws
		 * @param {String} message
		 * @returns {never}
		 */
		error(message: string): never;
		/**@type {Map<Symbol,RealNode>} */
		_sys: Map<Symbol, {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		}>;
		t0: number;
		tryRealNode: boolean;
		now: Promise<void>;
		eventLoop: any;
		/**
		 * @typedef {{
		 * tryRealNode: Boolean,
		 * childRNs: ({info: [RealNode,String[],String[]]} & RealNode)[],
		 * get()=>*,
		 * set(value)=>Boolean,
		 * react()=>Boolean,
		 * id: Symbol,
		 * value,
		 * }} AntiNode
		 */
		proto: {
			new (): {
				tryRealNode: any;
				/**@type {(RealNode & {info: [RealNode,String[],String[]]})[]} */
				childRNs: ({
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				} & {
					info: [{
						protoReact(): void;
						protoGet(): any;
						log(...message: any[]): void;
						done(): Promise<any>;
						/**
						 *
						 * @throws
						 * @param {String} message
						 * @returns {never}
						 */
						error(message: string): never;
						/**
						 *
						 * @returns {Boolean}
						 */
						protoSet(value: any): boolean;
						clearChildRNs(): /*elided*/ any;
						realReact(notify: boolean, noSelf: any): boolean;
						/**
						 *
						 * @returns {Promise[][]}
						 */
						protoDone(): Promise<any>[][];
						/**@type {Promise[][]} */
						notifyArray: Promise<any>[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 * @returns {?Promise<void>}
						 */
						notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
						/**
						 *
						 * @param {Boolean} react
						 * @param {Boolean} notify
						 * @param {Boolean} noSelf
						 * @returns {Boolean}
						 */
						realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
						/**
						 *
						 * @param {RealNode} realNode
						 * @returns {String[][]}
						 */
						_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 */
						protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
						/**
						 *
						 * @param {...(RealNode | Symbol)} relativeRNs
						 */
						relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
						/**
						 *
						 * @param {...(RealNode | Symbol)} unrelativeRNs
						 */
						unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
						/**
						 *
						 * @param {String[]} [position]
						 * @returns {[RealNode, ...string[]][]}
						 */
						_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
						/**
						 *
						 * @param {[RealNode, ...string[]][]} realNodeMap
						 */
						_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
						/**@type {Symbol} */
						readonly id: Symbol;
						readonly childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						value: any;
						set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
						get: () => any;
						react: () => boolean;
						display: boolean;
						tryRealNode: boolean;
						/**@type {Symbol[]} */
						relativeRNs: Symbol[];
						/**@type {AntiNode} */
						proto: {
							tryRealNode: boolean;
							childRNs: ({
								info: [/*elided*/ any, string[], string[]];
							} & /*elided*/ any)[];
							get(): any;
							set(value: any): boolean;
							react(): boolean;
							id: Symbol;
							value: any;
						};
						info: any;
						[Symbol.toPrimitive](hint: any): string | number;
					}, string[], string[]];
				})[];
				/**@type {()=>*} */
				get: () => any;
				/**@type {(value)=>Boolean} */
				set: (value: any) => boolean;
				/**@type {()=>Boolean} */
				react: () => boolean;
				/**@type {Symbol} */
				id: Symbol;
				value: any;
			};
		};
		/**
		 *
		 * @param {Symbol} id
		 */
		search(id: Symbol): {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		is(value1: any, value2: any): boolean;
		/**
		 *
		 * @param {()=>*} fn
		 * @returns {Promise}
		 */
		justNow(fn: () => any, thisArg: any, ...argArray: any[]): Promise<any>;
		arrayToObject(...args: any[]): any;
		/**@method */
		createExpression: (get: () => any, ...relativeRNs: {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		}[]) => {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		/**
		 *
		 * @param {RealNode} realNode
		 */
		check(realNode: {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		}): boolean;
		/**
		 *
		 * @type {(config: {get?: ()=>*,set?: (value)=>Boolean,react?: ()=>void,id?,info?,value?,initValue?})=>RealNode}
		 */
		createHidden: (config: {
			get?: () => any;
			set?: (value: any) => boolean;
			react?: () => void;
			id?: any;
			info?: any;
			value?: any;
			initValue?: any;
		}) => {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		/**
		 *
		 * @param {()=>*} fn
		 * @param {Boolean} keepNow
		 * @returns {Promise}
		 */
		afterNow(fn: () => any, keepNow: boolean, thisArg: any, ...argArray: any[]): Promise<any>;
		/**
		 *
		 * @param {()=>*} get
		 */
		protoCreate(get: () => any, ...argArray: any[]): {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		/**@method @type {((...args)=>RealNode)} */
		createNumber: ((...args: any) => {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		});
		/**@method @type {((...args)=>RealNode)} */
		createString: ((...args: any) => {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		});
		/**
		 *
		 * @param {(()=>*) & Promise} promise
		 * @param {(time: Number,error: Error | null,value)=>void} callback
		 * @returns {Promise<{error: ?Error,time: Number,value: ?*}>}
		 */
		time(promise: (() => any) & Promise<any>, callback: (time: number, error: Error | null, value: any) => void): Promise<{
			error: Error | null;
			time: number;
			value: any | null;
		}>;
		/**@method */
		copyObj: (obj: any) => any;
		/**
		 *
		 * @this {RealNode}
		 * @param {RealNode} realNode
		 */
		_react(this: {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		}, realNode: {
			protoReact(): void;
			protoGet(): any;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			/**
			 *
			 * @returns {Boolean}
			 */
			protoSet(value: any): boolean;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {Boolean} react
			 * @param {Boolean} notify
			 * @param {Boolean} noSelf
			 * @returns {Boolean}
			 */
			realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [/*elided*/ any, string[], string[]];
			} & /*elided*/ any)[];
			value: any;
			set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
			get: () => any;
			react: () => boolean;
			display: boolean;
			tryRealNode: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		}, react?: boolean, notify?: boolean, noSelf?: boolean): boolean;
	};
	var RealGroup: {
		new <T extends {}>({ id, info, self }?: {
			self?: T;
		}): {
			keys(all: any): (string | symbol)[];
			/**
			 *
			 * @param {Boolean} [notify]
			 * @param {Boolean} [noSelf]
			 * @returns {Boolean | Error}
			 */
			realSet(value: any, notify?: boolean, noSelf?: boolean): boolean | Error;
			/**
			 *
			 * @param {String | Symbol | ?(keyArray: (String | Symbol)[])=>Boolean} ifKeyOrFn
			 * @param {()=>void} listener
			 */
			addSetterListener(ifKeyOrFn: string | Symbol | (((keyArray: (string | Symbol)[]) => boolean) | null), listener: () => void): void;
			/**
			 *
			 * @param {(String | Symbol)[]} [keyArray]
			 */
			protoReact(keyArray?: (string | Symbol)[]): void;
			tryRealNodeSetter(): /*elided*/ any;
			/**
			 *
			 * @param {(key: String)=>Boolean} [filterFn]
			 * @returns {{}}
			 */
			getByFilter(filterFn?: (key: string) => boolean): {};
			/**
			 *
			 * @param {{}} obj
			 */
			protoSet(obj: {}): boolean;
			/**
			 *
			 * @param {String | Symbol | {}} [keyOrkeyObj]
			 */
			protoGet(keyOrkeyObj?: string | Symbol | {}, ...args: any[]): any;
			/**@type {()=>T} */
			readonly proxy: () => T;
			set: (value: any, notify?: boolean, noSelf?: boolean) => boolean | Error;
			/**@type {(keyOrkeyObj?: String | Symbol | {})=> *} */
			get: (keyOrkeyObj?: string | Symbol | {}) => any;
			react: (keyArray?: (string | Symbol)[]) => void;
			tryRealNode: boolean;
			/**@type {Map<String | Symbol | (keyArray: (String | Symbol)[])=>Boolean,(()=>void)[]>} */
			listenerMap: Map<string | Symbol | ((keyArray: (string | Symbol)[]) => boolean), (() => void)[]>;
			log(...message: any[]): void;
			done(): Promise<any>;
			/**
			 *
			 * @throws
			 * @param {String} message
			 * @returns {never}
			 */
			error(message: string): never;
			clearChildRNs(): /*elided*/ any;
			realReact(notify: boolean, noSelf: any): boolean;
			/**
			 *
			 * @returns {Promise[][]}
			 */
			protoDone(): Promise<any>[][];
			/**@type {Promise[][]} */
			notifyArray: Promise<any>[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 * @returns {?Promise<void>}
			 */
			notify(noSelf: boolean, thisArg?: {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, count?: number): Promise<void> | null;
			/**
			 *
			 * @param {RealNode} realNode
			 * @returns {String[][]}
			 */
			_getPositionsOfChildRN(realNode: {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}): string[][];
			/**
			 *
			 * @param {Boolean} noSelf
			 * @param {RealNode} [thisArg]
			 * @param {number} [count]
			 */
			protoNotify(noSelf: boolean, thisArg?: {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, count?: number): void;
			/**
			 *
			 * @param {...(RealNode | Symbol)} relativeRNs
			 */
			relate(...relativeRNs: ({
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			} | Symbol)[]): {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			};
			/**
			 *
			 * @param {...(RealNode | Symbol)} unrelativeRNs
			 */
			unrelate(...unrelativeRNs: ({
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			} | Symbol)[]): boolean;
			/**
			 *
			 * @param {String[]} [position]
			 * @returns {[RealNode, ...string[]][]}
			 */
			_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [{
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, ...string[]][];
			/**
			 *
			 * @param {[RealNode, ...string[]][]} realNodeMap
			 */
			_dealWithPositionsOfRNs(realNodeMap: [{
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			}, ...string[]][], expression: any): any;
			/**@type {Symbol} */
			readonly id: Symbol;
			readonly childRNs: ({
				info: [{
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: (/*elided*/ any & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, string[], string[]];
			} & {
				protoReact(): void;
				protoGet(): any;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				/**
				 *
				 * @returns {Boolean}
				 */
				protoSet(value: any): boolean;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {Boolean} react
				 * @param {Boolean} notify
				 * @param {Boolean} noSelf
				 * @returns {Boolean}
				 */
				realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [/*elided*/ any, string[], string[]];
				} & /*elided*/ any)[];
				value: any;
				set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
				get: () => any;
				react: () => boolean;
				display: boolean;
				tryRealNode: boolean;
				/**@type {Symbol[]} */
				relativeRNs: Symbol[];
				/**@type {AntiNode} */
				proto: {
					tryRealNode: boolean;
					childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					get(): any;
					set(value: any): boolean;
					react(): boolean;
					id: Symbol;
					value: any;
				};
				info: any;
				[Symbol.toPrimitive](hint: any): string | number;
			})[];
			value: any;
			display: boolean;
			/**@type {Symbol[]} */
			relativeRNs: Symbol[];
			/**@type {AntiNode} */
			proto: {
				tryRealNode: boolean;
				childRNs: ({
					info: [{
						protoReact(): void;
						protoGet(): any;
						log(...message: any[]): void;
						done(): Promise<any>;
						/**
						 *
						 * @throws
						 * @param {String} message
						 * @returns {never}
						 */
						error(message: string): never;
						/**
						 *
						 * @returns {Boolean}
						 */
						protoSet(value: any): boolean;
						clearChildRNs(): /*elided*/ any;
						realReact(notify: boolean, noSelf: any): boolean;
						/**
						 *
						 * @returns {Promise[][]}
						 */
						protoDone(): Promise<any>[][];
						/**@type {Promise[][]} */
						notifyArray: Promise<any>[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 * @returns {?Promise<void>}
						 */
						notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
						/**
						 *
						 * @param {Boolean} react
						 * @param {Boolean} notify
						 * @param {Boolean} noSelf
						 * @returns {Boolean}
						 */
						realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
						/**
						 *
						 * @param {RealNode} realNode
						 * @returns {String[][]}
						 */
						_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 */
						protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
						/**
						 *
						 * @param {...(RealNode | Symbol)} relativeRNs
						 */
						relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
						/**
						 *
						 * @param {...(RealNode | Symbol)} unrelativeRNs
						 */
						unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
						/**
						 *
						 * @param {String[]} [position]
						 * @returns {[RealNode, ...string[]][]}
						 */
						_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
						/**
						 *
						 * @param {[RealNode, ...string[]][]} realNodeMap
						 */
						_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
						/**@type {Symbol} */
						readonly id: Symbol;
						readonly childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						value: any;
						set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
						get: () => any;
						react: () => boolean;
						display: boolean;
						tryRealNode: boolean;
						/**@type {Symbol[]} */
						relativeRNs: Symbol[];
						/**@type {AntiNode} */
						proto: /*elided*/ any;
						info: any;
						[Symbol.toPrimitive](hint: any): string | number;
					}, string[], string[]];
				} & {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: /*elided*/ any;
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				})[];
				get(): any;
				set(value: any): boolean;
				react(): boolean;
				id: Symbol;
				value: any;
			};
			info: any;
			[Symbol.toPrimitive](hint: any): string | number;
		};
		tempProxy: {
			new (self: {}, realGroup: {
				keys(all: any): (string | symbol)[];
				/**
				 *
				 * @param {Boolean} [notify]
				 * @param {Boolean} [noSelf]
				 * @returns {Boolean | Error}
				 */
				realSet(value: any, notify?: boolean, noSelf?: boolean): boolean | Error;
				/**
				 *
				 * @param {String | Symbol | ?(keyArray: (String | Symbol)[])=>Boolean} ifKeyOrFn
				 * @param {()=>void} listener
				 */
				addSetterListener(ifKeyOrFn: string | Symbol | ((keyArray: (string | Symbol)[]) => boolean), listener: () => void): void;
				/**
				 *
				 * @param {(String | Symbol)[]} [keyArray]
				 */
				protoReact(keyArray?: (string | Symbol)[]): void;
				tryRealNodeSetter(): /*elided*/ any;
				/**
				 *
				 * @param {(key: String)=>Boolean} [filterFn]
				 * @returns {{}}
				 */
				getByFilter(filterFn?: (key: string) => boolean): {};
				/**
				 *
				 * @param {{}} obj
				 */
				protoSet(obj: {}): boolean;
				/**
				 *
				 * @param {String | Symbol | {}} [keyOrkeyObj]
				 */
				protoGet(keyOrkeyObj?: string | Symbol | {}, ...args: any[]): any;
				/**@type {()=>T} */
				readonly proxy: () => any;
				set: (value: any, notify?: boolean, noSelf?: boolean) => boolean | Error;
				/**@type {(keyOrkeyObj?: String | Symbol | {})=> *} */
				get: (keyOrkeyObj?: string | Symbol | {}) => any;
				react: (keyArray?: (string | Symbol)[]) => void;
				tryRealNode: boolean;
				/**@type {Map<String | Symbol | (keyArray: (String | Symbol)[])=>Boolean,(()=>void)[]>} */
				listenerMap: Map<string | Symbol | ((keyArray: (string | Symbol)[]) => boolean), (() => void)[]>;
				log(...message: any[]): void;
				done(): Promise<any>;
				/**
				 *
				 * @throws
				 * @param {String} message
				 * @returns {never}
				 */
				error(message: string): never;
				clearChildRNs(): /*elided*/ any;
				realReact(notify: boolean, noSelf: any): boolean;
				/**
				 *
				 * @returns {Promise[][]}
				 */
				protoDone(): Promise<any>[][];
				/**@type {Promise[][]} */
				notifyArray: Promise<any>[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 * @returns {?Promise<void>}
				 */
				notify(noSelf: boolean, thisArg?: {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, count?: number): Promise<void> | null;
				/**
				 *
				 * @param {RealNode} realNode
				 * @returns {String[][]}
				 */
				_getPositionsOfChildRN(realNode: {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}): string[][];
				/**
				 *
				 * @param {Boolean} noSelf
				 * @param {RealNode} [thisArg]
				 * @param {number} [count]
				 */
				protoNotify(noSelf: boolean, thisArg?: {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, count?: number): void;
				/**
				 *
				 * @param {...(RealNode | Symbol)} relativeRNs
				 */
				relate(...relativeRNs: ({
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				} | Symbol)[]): {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				};
				/**
				 *
				 * @param {...(RealNode | Symbol)} unrelativeRNs
				 */
				unrelate(...unrelativeRNs: ({
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				} | Symbol)[]): boolean;
				/**
				 *
				 * @param {String[]} [position]
				 * @returns {[RealNode, ...string[]][]}
				 */
				_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [{
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, ...string[]][];
				/**
				 *
				 * @param {[RealNode, ...string[]][]} realNodeMap
				 */
				_dealWithPositionsOfRNs(realNodeMap: [{
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
					/**
					 *
					 * @param {...(RealNode | Symbol)} relativeRNs
					 */
					relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
					/**
					 *
					 * @param {...(RealNode | Symbol)} unrelativeRNs
					 */
					unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
					/**
					 *
					 * @param {String[]} [position]
					 * @returns {[RealNode, ...string[]][]}
					 */
					_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
					/**
					 *
					 * @param {[RealNode, ...string[]][]} realNodeMap
					 */
					_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
					/**@type {Symbol} */
					readonly id: Symbol;
					readonly childRNs: ({
						info: [/*elided*/ any, string[], string[]];
					} & /*elided*/ any)[];
					value: any;
					set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
					get: () => any;
					react: () => boolean;
					display: boolean;
					tryRealNode: boolean;
					/**@type {Symbol[]} */
					relativeRNs: Symbol[];
					/**@type {AntiNode} */
					proto: {
						tryRealNode: boolean;
						childRNs: ({
							info: [/*elided*/ any, string[], string[]];
						} & /*elided*/ any)[];
						get(): any;
						set(value: any): boolean;
						react(): boolean;
						id: Symbol;
						value: any;
					};
					info: any;
					[Symbol.toPrimitive](hint: any): string | number;
				}, ...string[]][], expression: any): any;
				/**@type {Symbol} */
				readonly id: Symbol;
				readonly childRNs: ({
					info: [{
						protoReact(): void;
						protoGet(): any;
						log(...message: any[]): void;
						done(): Promise<any>;
						/**
						 *
						 * @throws
						 * @param {String} message
						 * @returns {never}
						 */
						error(message: string): never;
						/**
						 *
						 * @returns {Boolean}
						 */
						protoSet(value: any): boolean;
						clearChildRNs(): /*elided*/ any;
						realReact(notify: boolean, noSelf: any): boolean;
						/**
						 *
						 * @returns {Promise[][]}
						 */
						protoDone(): Promise<any>[][];
						/**@type {Promise[][]} */
						notifyArray: Promise<any>[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 * @returns {?Promise<void>}
						 */
						notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
						/**
						 *
						 * @param {Boolean} react
						 * @param {Boolean} notify
						 * @param {Boolean} noSelf
						 * @returns {Boolean}
						 */
						realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
						/**
						 *
						 * @param {RealNode} realNode
						 * @returns {String[][]}
						 */
						_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
						/**
						 *
						 * @param {Boolean} noSelf
						 * @param {RealNode} [thisArg]
						 * @param {number} [count]
						 */
						protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void;
						/**
						 *
						 * @param {...(RealNode | Symbol)} relativeRNs
						 */
						relate(...relativeRNs: (/*elided*/ any | Symbol)[]): /*elided*/ any;
						/**
						 *
						 * @param {...(RealNode | Symbol)} unrelativeRNs
						 */
						unrelate(...unrelativeRNs: (/*elided*/ any | Symbol)[]): boolean;
						/**
						 *
						 * @param {String[]} [position]
						 * @returns {[RealNode, ...string[]][]}
						 */
						_computePositionsOfRNs(value: any, deep?: number, position?: string[], count?: number): [/*elided*/ any, ...string[]][];
						/**
						 *
						 * @param {[RealNode, ...string[]][]} realNodeMap
						 */
						_dealWithPositionsOfRNs(realNodeMap: [/*elided*/ any, ...string[]][], expression: any): any;
						/**@type {Symbol} */
						readonly id: Symbol;
						readonly childRNs: (/*elided*/ any & /*elided*/ any)[];
						value: any;
						set: (value: any, react: boolean, notify: boolean, noSelf: boolean) => boolean;
						get: () => any;
						react: () => boolean;
						display: boolean;
						tryRealNode: boolean;
						/**@type {Symbol[]} */
						relativeRNs: Symbol[];
						/**@type {AntiNode} */
						proto: {
							tryRealNode: boolean;
							childRNs: ({
								info: [/*elided*/ any, string[], string[]];
							} & /*elided*/ any)[];
							get(): any;
							set(value: any): boolean;
							react(): boolean;
							id: Symbol;
							value: any;
						};
						info: any;
						[Symbol.toPrimitive](hint: any): string | number;
					}, string[], string[]];
				} & {
					protoReact(): void;
					protoGet(): any;
					log(...message: any[]): void;
					done(): Promise<any>;
					/**
					 *
					 * @throws
					 * @param {String} message
					 * @returns {never}
					 */
					error(message: string): never;
					/**
					 *
					 * @returns {Boolean}
					 */
					protoSet(value: any): boolean;
					clearChildRNs(): /*elided*/ any;
					realReact(notify: boolean, noSelf: any): boolean;
					/**
					 *
					 * @returns {Promise[][]}
					 */
					protoDone(): Promise<any>[][];
					/**@type {Promise[][]} */
					notifyArray: Promise<any>[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 * @returns {?Promise<void>}
					 */
					notify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): Promise<void> | null;
					/**
					 *
					 * @param {Boolean} react
					 * @param {Boolean} notify
					 * @param {Boolean} noSelf
					 * @returns {Boolean}
					 */
					realSet(value: any, react: boolean, notify: boolean, noSelf: boolean): boolean;
					/**
					 *
					 * @param {RealNode} realNode
					 * @returns {String[][]}
					 */
					_getPositionsOfChildRN(realNode: /*elided*/ any): string[][];
					/**
					 *
					 * @param {Boolean} noSelf
					 * @param {RealNode} [thisArg]
					 * @param {number} [count]
					 */
					protoNotify(noSelf: boolean, thisArg?: /*elided*/ any, count?: number): void; /*... 15 more elided ...*/
					[Symbol.toPrimitive](hint: any): string | number;
				})[]; /*... 5 more elided ...*/
				[Symbol.toPrimitive](hint: any): string | number;
			}): {
				/*elided*/
			};
			arr: any[];
		}; /*... 23 more elided ...*/
		/**
		 *
		 * @this {RealNode}
		 * @param {RealNode} realNode
		 */
		_react(this: {
			/*elided*/
		}, realNode: {
			/*elided*/
		}, react?: boolean, notify?: boolean, noSelf?: boolean): boolean;
	};
	var RealTarget: {
		/*elided*/
	};
	var RealElement: {
		/*elided*/
	};
	/**
	 *
	 * @param {{[key: String]: *}} [optionConfig]
	 * @param {Boolean} [multiple]
	 * @param {(this: RealDivList,e: Event)=>void} [onchange]
	 */
	function createRealDivSelect(optionConfig?: {
		[key: string]: any;
	}, multiple?: boolean, onchange?: (this: {
		/*elided*/
	}, e: Event) => void): {
		/*elided*/
	};
	/**
	 *
	 * @param {String} [placeholder]
	 */
	function createRealDivSearch(placeholder?: string): {
		/*elided*/
	};
	/**
	 *
	 * @param {String | RealNode | ()=>String} titleGetter
	 */
	function createRealDivSeries(titleGetter: string | {
		/*elided*/
	} | (() => string)): {
		/*elided*/
	};
	var RealCanvas: {
		/*elided*/
	};
	var RealLoader: {
		/*elided*/
	};
	var RealSelect: {
		/*elided*/
	};
	var RealComtag: {
		/*elided*/
	};
	var RealDivList: {
		/*elided*/
	};
	var RealImgList: {
		/*elided*/
	};
	var RealDivQueue: {
		/*elided*/
	};
}
